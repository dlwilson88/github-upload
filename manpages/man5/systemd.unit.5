'\" t
.TH "SYSTEMD\&.UNIT" "5" "" "systemd 242" "systemd.unit"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
systemd.unit \- Unit configuration
.SH "SYNOPSIS"
.PP
\fIservice\fR\&.service,
\fIsocket\fR\&.socket,
\fIdevice\fR\&.device,
\fImount\fR\&.mount,
\fIautomount\fR\&.automount,
\fIswap\fR\&.swap,
\fItarget\fR\&.target,
\fIpath\fR\&.path,
\fItimer\fR\&.timer,
\fIslice\fR\&.slice,
\fIscope\fR\&.scope
.SS "System Unit Search Path"
.PP
.nf
/etc/systemd/system\&.control/*
/run/systemd/system\&.control/*
/run/systemd/transient/*
/run/systemd/generator\&.early/*
/etc/systemd/system/*
/etc/systemd/systemd\&.attached/*
/run/systemd/system/*
/run/systemd/systemd\&.attached/*
/run/systemd/generator/*
\&...
/usr/lib/systemd/system/*
/run/systemd/generator\&.late/*
.fi
.SS "User Unit Search Path"
.PP
.nf
~/\&.config/systemd/user\&.control/*
$XDG_RUNTIME_DIR/systemd/user\&.control/*
$XDG_RUNTIME_DIR/systemd/transient/*
$XDG_RUNTIME_DIR/systemd/generator\&.early/*
~/\&.config/systemd/user/*
/etc/systemd/user/*
$XDG_RUNTIME_DIR/systemd/user/*
/run/systemd/user/*
$XDG_RUNTIME_DIR/systemd/generator/*
~/\&.local/share/systemd/user/*
\&...
/usr/lib/systemd/user/*
$XDG_RUNTIME_DIR/systemd/generator\&.late/*
.fi
.SH "DESCRIPTION"
.PP
A unit file is a plain text ini\-style file that encodes information about a service, a socket, a device, a mount point, an automount point, a swap file or partition, a start\-up target, a watched file system path, a timer controlled and supervised by
\fBsystemd\fR(1), a resource management slice or a group of externally created processes\&. See
\fBsystemd.syntax\fR(5)
for a general description of the syntax\&.
.PP
This man page lists the common configuration options of all the unit types\&. These options need to be configured in the [Unit] or [Install] sections of the unit files\&.
.PP
In addition to the generic [Unit] and [Install] sections described here, each unit may have a type\-specific section, e\&.g\&. [Service] for a service unit\&. See the respective man pages for more information:
\fBsystemd.service\fR(5),
\fBsystemd.socket\fR(5),
\fBsystemd.device\fR(5),
\fBsystemd.mount\fR(5),
\fBsystemd.automount\fR(5),
\fBsystemd.swap\fR(5),
\fBsystemd.target\fR(5),
\fBsystemd.path\fR(5),
\fBsystemd.timer\fR(5),
\fBsystemd.slice\fR(5),
\fBsystemd.scope\fR(5)\&.
.PP
Unit files are loaded from a set of paths determined during compilation, described in the next section\&.
.PP
Unit files can be parameterized by a single argument called the "instance name"\&. The unit is then constructed based on a "template file" which serves as the definition of multiple services or other units\&. A template unit must have a single
"@"
at the end of the name (right before the type suffix)\&. The name of the full unit is formed by inserting the instance name between
"@"
and the unit type suffix\&. In the unit file itself, the instance parameter may be referred to using
"%i"
and other specifiers, see below\&.
.PP
Unit files may contain additional options on top of those listed here\&. If systemd encounters an unknown option, it will write a warning log message but continue loading the unit\&. If an option or section name is prefixed with
\fBX\-\fR, it is ignored completely by systemd\&. Options within an ignored section do not need the prefix\&. Applications may use this to include additional information in the unit files\&.
.PP
Units can be aliased (have an alternative name), by creating a symlink from the new name to the existing name in one of the unit search paths\&. For example,
systemd\-networkd\&.service
has the alias
dbus\-org\&.freedesktop\&.network1\&.service, created during installation as the symlink
/usr/lib/systemd/system/dbus\-org\&.freedesktop\&.network1\&.service\&. In addition, unit files may specify aliases through the
\fIAlias=\fR
directive in the [Install] section; those aliases are only effective when the unit is enabled\&. When the unit is enabled, symlinks will be created for those names, and removed when the unit is disabled\&. For example,
reboot\&.target
specifies
\fIAlias=ctrl\-alt\-del\&.target\fR, so when enabled it will be invoked whenever CTRL+ALT+DEL is pressed\&. Alias names may be used in commands like
\fBenable\fR,
\fBdisable\fR,
\fBstart\fR,
\fBstop\fR,
\fBstatus\fR, \&..., and in unit dependency directives
\fIWants=\fR,
\fIRequires=\fR,
\fIBefore=\fR,
\fIAfter=\fR, \&..., with the limitation that aliases specified through
\fIAlias=\fR
are only effective when the unit is enabled\&. Aliases cannot be used with the
\fBpreset\fR
command\&.
.PP
Along with a unit file
foo\&.service, the directory
foo\&.service\&.wants/
may exist\&. All unit files symlinked from such a directory are implicitly added as dependencies of type
\fIWants=\fR
to the unit\&. This is useful to hook units into the start\-up of other units, without having to modify their unit files\&. For details about the semantics of
\fIWants=\fR, see below\&. The preferred way to create symlinks in the
\&.wants/
directory of a unit file is with the
\fBenable\fR
command of the
\fBsystemctl\fR(1)
tool which reads information from the [Install] section of unit files (see below)\&. A similar functionality exists for
\fIRequires=\fR
type dependencies as well, the directory suffix is
\&.requires/
in this case\&.
.PP
Along with a unit file
foo\&.service, a "drop\-in" directory
foo\&.service\&.d/
may exist\&. All files with the suffix
"\&.conf"
from this directory will be parsed after the unit file itself is parsed\&. This is useful to alter or add configuration settings for a unit, without having to modify unit files\&. Drop\-in files must contain appropriate section headers\&. For instantiated units, this logic will first look for the instance
"\&.d/"
subdirectory (e\&.g\&.
"foo@bar\&.service\&.d/") and read its
"\&.conf"
files, followed by the template
"\&.d/"
subdirectory (e\&.g\&.
"foo@\&.service\&.d/") and the
"\&.conf"
files there\&. Moreover for units names containing dashes ("\-"), the set of directories generated by truncating the unit name after all dashes is searched too\&. Specifically, for a unit name
foo\-bar\-baz\&.service
not only the regular drop\-in directory
foo\-bar\-baz\&.service\&.d/
is searched but also both
foo\-bar\-\&.service\&.d/
and
foo\-\&.service\&.d/\&. This is useful for defining common drop\-ins for a set of related units, whose names begin with a common prefix\&. This scheme is particularly useful for mount, automount and slice units, whose systematic naming structure is built around dashes as component separators\&. Note that equally named drop\-in files further down the prefix hierarchy override those further up, i\&.e\&.
foo\-bar\-\&.service\&.d/10\-override\&.conf
overrides
foo\-\&.service\&.d/10\-override\&.conf\&.
.PP
In addition to
/etc/systemd/system, the drop\-in
"\&.d/"
directories for system services can be placed in
/usr/lib/systemd/system
or
/run/systemd/system
directories\&. Drop\-in files in
/etc
take precedence over those in
/run
which in turn take precedence over those in
/usr/lib\&. Drop\-in files under any of these directories take precedence over unit files wherever located\&. Multiple drop\-in files with different names are applied in lexicographic order, regardless of which of the directories they reside in\&.
.PP
Note that while systemd offers a flexible dependency system between units it is recommended to use this functionality only sparingly and instead rely on techniques such as bus\-based or socket\-based activation which make dependencies implicit, resulting in a both simpler and more flexible system\&.
.PP
As mentioned above, a unit may be instantiated from a template file\&. This allows creation of multiple units from a single configuration file\&. If systemd looks for a unit configuration file, it will first search for the literal unit name in the file system\&. If that yields no success and the unit name contains an
"@"
character, systemd will look for a unit template that shares the same name but with the instance string (i\&.e\&. the part between the
"@"
character and the suffix) removed\&. Example: if a service
getty@tty3\&.service
is requested and no file by that name is found, systemd will look for
getty@\&.service
and instantiate a service from that configuration file if it is found\&.
.PP
To refer to the instance string from within the configuration file you may use the special
"%i"
specifier in many of the configuration options\&. See below for details\&.
.PP
If a unit file is empty (i\&.e\&. has the file size 0) or is symlinked to
/dev/null, its configuration will not be loaded and it appears with a load state of
"masked", and cannot be activated\&. Use this as an effective way to fully disable a unit, making it impossible to start it even manually\&.
.PP
The unit file format is covered by the
\m[blue]\fBInterface Stability Promise\fR\m[]\&\s-2\u[1]\d\s+2\&.
.SH "STRING ESCAPING FOR INCLUSION IN UNIT NAMES"
.PP
Sometimes it is useful to convert arbitrary strings into unit names\&. To facilitate this, a method of string escaping is used, in order to map strings containing arbitrary byte values (except NUL) into valid unit names and their restricted character set\&. A common special case are unit names that reflect paths to objects in the file system hierarchy\&. Example: a device unit
dev\-sda\&.device
refers to a device with the device node
/dev/sda
in the file system\&.
.PP
The escaping algorithm operates as follows: given a string, any
"/"
character is replaced by
"\-", and all other characters which are not ASCII alphanumerics or
"_"
are replaced by C\-style
"\ex2d"
escapes\&. In addition,
"\&."
is replaced with such a C\-style escape when it would appear as the first character in the escaped string\&.
.PP
When the input qualifies as absolute file system path, this algorithm is extended slightly: the path to the root directory
"/"
is encoded as single dash
"\-"\&. In addition, any leading, trailing or duplicate
"/"
characters are removed from the string before transformation\&. Example:
/foo//bar/baz/
becomes
"foo\-bar\-baz"\&.
.PP
This escaping is fully reversible, as long as it is known whether the escaped string was a path (the unescaping results are different for paths and non\-path strings)\&. The
\fBsystemd-escape\fR(1)
command may be used to apply and reverse escaping on arbitrary strings\&. Use
\fBsystemd\-escape \-\-path\fR
to escape path strings, and
\fBsystemd\-escape\fR
without
\fB\-\-path\fR
otherwise\&.
.SH "AUTOMATIC DEPENDENCIES"
.SS "Implicit Dependencies"
.PP
A number of unit dependencies are implicitly established, depending on unit type and unit configuration\&. These implicit dependencies can make unit configuration file cleaner\&. For the implicit dependencies in each unit type, please refer to section "Implicit Dependencies" in respective man pages\&.
.PP
For example, service units with
\fIType=dbus\fR
automatically acquire dependencies of type
\fIRequires=\fR
and
\fIAfter=\fR
on
dbus\&.socket\&. See
\fBsystemd.service\fR(5)
for details\&.
.SS "Default Dependencies"
.PP
Default dependencies are similar to implicit dependencies, but can be turned on and off by setting
\fIDefaultDependencies=\fR
to
\fIyes\fR
(the default) and
\fIno\fR, while implicit dependencies are always in effect\&. See section "Default Dependencies" in respective man pages for the effect of enabling
\fIDefaultDependencies=\fR
in each unit types\&.
.PP
For example, target units will complement all configured dependencies of type
\fIWants=\fR
or
\fIRequires=\fR
with dependencies of type
\fIAfter=\fR
unless
\fIDefaultDependencies=no\fR
is set in the specified units\&. See
\fBsystemd.target\fR(5)
for details\&. Note that this behavior can be turned off by setting
\fIDefaultDependencies=no\fR\&.
.SH "UNIT FILE LOAD PATH"
.PP
Unit files are loaded from a set of paths determined during compilation, described in the two tables below\&. Unit files found in directories listed earlier override files with the same name in directories lower in the list\&.
.PP
When the variable
\fI$SYSTEMD_UNIT_PATH\fR
is set, the contents of this variable overrides the unit load path\&. If
\fI$SYSTEMD_UNIT_PATH\fR
ends with an empty component (":"), the usual unit load path will be appended to the contents of the variable\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&1.\ \& Load path when running in system mode (\-\-system)\&.
.TS
allbox tab(:);
lB lB.
T{
Path
T}:T{
Description
T}
.T&
l l
l ^
l l
l l
l l
l l
l l
l l
l l
l l.
T{
/etc/systemd/system\&.control
T}:T{
Persistent and transient configuration created using the dbus API
T}
T{
/run/systemd/system\&.control
T}:
T{
/run/systemd/transient
T}:T{
Dynamic configuration for transient units
T}
T{
/run/systemd/generator\&.early
T}:T{
Generated units with high priority (see \fIearly\-dir\fR in \fBsystemd.generator\fR(7))
T}
T{
/etc/systemd/system
T}:T{
System units created by the administrator
T}
T{
/run/systemd/system
T}:T{
Runtime units
T}
T{
/run/systemd/generator
T}:T{
Generated units with medium priority (see \fInormal\-dir\fR in \fBsystemd.generator\fR(7))
T}
T{
/usr/local/lib/systemd/system
T}:T{
System units installed by the administrator
T}
T{
/usr/lib/systemd/system
T}:T{
System units installed by the distribution package manager
T}
T{
/run/systemd/generator\&.late
T}:T{
Generated units with low priority (see \fIlate\-dir\fR in \fBsystemd.generator\fR(7))
T}
.TE
.sp 1
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&2.\ \& Load path when running in user mode (\-\-user)\&.
.TS
allbox tab(:);
lB lB.
T{
Path
T}:T{
Description
T}
.T&
l l
l ^
l l
l l
l l
l l
l l
l l
l l
l l
l l
l l
l l
l l.
T{
$XDG_CONFIG_HOME/systemd/user\&.control or ~/\&.config/systemd/user\&.control
T}:T{
Persistent and transient configuration created using the dbus API (\fI$XDG_CONFIG_HOME\fR is used if set, ~/\&.config otherwise)
T}
T{
$XDG_RUNTIME_DIR/systemd/user\&.control
T}:
T{
/run/systemd/transient
T}:T{
Dynamic configuration for transient units
T}
T{
/run/systemd/generator\&.early
T}:T{
Generated units with high priority (see \fIearly\-dir\fR in \fBsystemd.generator\fR(7))
T}
T{
$XDG_CONFIG_HOME/systemd/user or $HOME/\&.config/systemd/user
T}:T{
User configuration (\fI$XDG_CONFIG_HOME\fR is used if set, ~/\&.config otherwise)
T}
T{
/etc/systemd/user
T}:T{
User units created by the administrator
T}
T{
$XDG_RUNTIME_DIR/systemd/user
T}:T{
Runtime units (only used when $XDG_RUNTIME_DIR is set)
T}
T{
/run/systemd/user
T}:T{
Runtime units
T}
T{
$XDG_RUNTIME_DIR/systemd/generator
T}:T{
Generated units with medium priority (see \fInormal\-dir\fR in \fBsystemd.generator\fR(7))
T}
T{
$XDG_DATA_HOME/systemd/user or $HOME/\&.local/share/systemd/user
T}:T{
Units of packages that have been installed in the home directory (\fI$XDG_DATA_HOME\fR is used if set, ~/\&.local/share otherwise)
T}
T{
$dir/systemd/user for each \fI$dir\fR in \fI$XDG_DATA_DIRS\fR
T}:T{
Additional locations for installed user units, one for each entry in \fI$XDG_DATA_DIRS\fR
T}
T{
/usr/local/lib/systemd/user
T}:T{
User units installed by the administrator
T}
T{
/usr/lib/systemd/user
T}:T{
User units installed by the distribution package manager
T}
T{
$XDG_RUNTIME_DIR/systemd/generator\&.late
T}:T{
Generated units with low priority (see \fIlate\-dir\fR in \fBsystemd.generator\fR(7))
T}
.TE
.sp 1
.PP
The set of load paths for the user manager instance may be augmented or changed using various environment variables\&. And environment variables may in turn be set using environment generators, see
\fBsystemd.environment-generator\fR(7)\&. In particular,
\fI$XDG_DATA_HOME\fR
and
\fI$XDG_DATA_DIRS\fR
may be easily set using
\fBsystemd-environment-d-generator\fR(8)\&. Thus, directories listed here are just the defaults\&. To see the actual list that would be used based on compilation options and current environment use
.sp
.if n \{\
.RS 4
.\}
.nf
systemd\-analyze \-\-user unit\-paths
.fi
.if n \{\
.RE
.\}
.PP
Moreover, additional units might be loaded into systemd ("linked") from directories not on the unit load path\&. See the
\fBlink\fR
command for
\fBsystemctl\fR(1)\&.
.SH "UNIT GARBAGE COLLECTION"
.PP
The system and service manager loads a unit\*(Aqs configuration automatically when a unit is referenced for the first time\&. It will automatically unload the unit configuration and state again when the unit is not needed anymore ("garbage collection")\&. A unit may be referenced through a number of different mechanisms:
.sp
.RS 4
.ie n \{\
\h'-04' 1.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  1." 4.2
.\}
Another loaded unit references it with a dependency such as
\fIAfter=\fR,
\fIWants=\fR, \&...
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 2.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  2." 4.2
.\}
The unit is currently starting, running, reloading or stopping\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 3.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  3." 4.2
.\}
The unit is currently in the
\fBfailed\fR
state\&. (But see below\&.)
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 4.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  4." 4.2
.\}
A job for the unit is pending\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 5.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  5." 4.2
.\}
The unit is pinned by an active IPC client program\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 6.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  6." 4.2
.\}
The unit is a special "perpetual" unit that is always active and loaded\&. Examples for perpetual units are the root mount unit
\-\&.mount
or the scope unit
init\&.scope
that the service manager itself lives in\&.
.RE
.sp
.RS 4
.ie n \{\
\h'-04' 7.\h'+01'\c
.\}
.el \{\
.sp -1
.IP "  7." 4.2
.\}
The unit has running processes associated with it\&.
.RE
.PP
The garbage collection logic may be altered with the
\fICollectMode=\fR
option, which allows configuration whether automatic unloading of units that are in
\fBfailed\fR
state is permissible, see below\&.
.PP
Note that when a unit\*(Aqs configuration and state is unloaded, all execution results, such as exit codes, exit signals, resource consumption and other statistics are lost, except for what is stored in the log subsystem\&.
.PP
Use
\fBsystemctl daemon\-reload\fR
or an equivalent command to reload unit configuration while the unit is already loaded\&. In this case all configuration settings are flushed out and replaced with the new configuration (which however might not be in effect immediately), however all runtime state is saved/restored\&.
.SH "[UNIT] SECTION OPTIONS"
.PP
The unit file may include a [Unit] section, which carries generic information about the unit that is not dependent on the type of unit:
.PP
\fIDescription=\fR
.RS 4
A human readable name for the unit\&. This is used by
\fBsystemd\fR
(and other UIs) as the label for the unit, so this string should identify the unit rather than describe it, despite the name\&.
"Apache2 Web Server"
is a good example\&. Bad examples are
"high\-performance light\-weight HTTP server"
(too generic) or
"Apache2"
(too specific and meaningless for people who do not know Apache)\&.
\fBsystemd\fR
will use this string as a noun in status messages ("Starting \fIdescription\fR\&.\&.\&.",
"Started \fIdescription\fR\&.",
"Reached target \fIdescription\fR\&.",
"Failed to start \fIdescription\fR\&."), so it should be capitalized, and should not be a full sentence or a phrase with a continuous verb\&. Bad examples include
"exiting the container"
or
"updating the database once per day\&."\&.
.RE
.PP
\fIDocumentation=\fR
.RS 4
A space\-separated list of URIs referencing documentation for this unit or its configuration\&. Accepted are only URIs of the types
"http://",
"https://",
"file:",
"info:",
"man:"\&. For more information about the syntax of these URIs, see
\fBuri\fR(7)\&. The URIs should be listed in order of relevance, starting with the most relevant\&. It is a good idea to first reference documentation that explains what the unit\*(Aqs purpose is, followed by how it is configured, followed by any other related documentation\&. This option may be specified more than once, in which case the specified list of URIs is merged\&. If the empty string is assigned to this option, the list is reset and all prior assignments will have no effect\&.
.RE
.PP
\fIRequires=\fR
.RS 4
Configures requirement dependencies on other units\&. If this unit gets activated, the units listed here will be activated as well\&. If one of the other units fails to activate, and an ordering dependency
\fIAfter=\fR
on the failing unit is set, this unit will not be started\&. Besides, with or without specifying
\fIAfter=\fR, this unit will be stopped if one of the other units is explicitly stopped\&. This option may be specified more than once or multiple space\-separated units may be specified in one option in which case requirement dependencies for all listed names will be created\&. Note that requirement dependencies do not influence the order in which services are started or stopped\&. This has to be configured independently with the
\fIAfter=\fR
or
\fIBefore=\fR
options\&. If a unit
foo\&.service
requires a unit
bar\&.service
as configured with
\fIRequires=\fR
and no ordering is configured with
\fIAfter=\fR
or
\fIBefore=\fR, then both units will be started simultaneously and without any delay between them if
foo\&.service
is activated\&. Often, it is a better choice to use
\fIWants=\fR
instead of
\fIRequires=\fR
in order to achieve a system that is more robust when dealing with failing services\&.
.sp
Note that this dependency type does not imply that the other unit always has to be in active state when this unit is running\&. Specifically: failing condition checks (such as
\fIConditionPathExists=\fR,
\fIConditionPathIsSymbolicLink=\fR, \&... \(em see below) do not cause the start job of a unit with a
\fIRequires=\fR
dependency on it to fail\&. Also, some unit types may deactivate on their own (for example, a service process may decide to exit cleanly, or a device may be unplugged by the user), which is not propagated to units having a
\fIRequires=\fR
dependency\&. Use the
\fIBindsTo=\fR
dependency type together with
\fIAfter=\fR
to ensure that a unit may never be in active state without a specific other unit also in active state (see below)\&.
.sp
Note that dependencies of this type may also be configured outside of the unit configuration file by adding a symlink to a
\&.requires/
directory accompanying the unit file\&. For details, see above\&.
.RE
.PP
\fIRequisite=\fR
.RS 4
Similar to
\fIRequires=\fR\&. However, if the units listed here are not started already, they will not be started and the starting of this unit will fail immediately\&.
\fIRequisite=\fR
does not imply an ordering dependency, even if both units are started in the same transaction\&. Hence this setting should usually be combined with
\fIAfter=\fR, to ensure this unit is not started before the other unit\&.
.sp
When
\fIRequisite=b\&.service\fR
is used on
a\&.service, this dependency will show as
\fIRequisiteOf=a\&.service\fR
in property listing of
b\&.service\&.
\fIRequisiteOf=\fR
dependency cannot be specified directly\&.
.RE
.PP
\fIWants=\fR
.RS 4
A weaker version of
\fIRequires=\fR\&. Units listed in this option will be started if the configuring unit is\&. However, if the listed units fail to start or cannot be added to the transaction, this has no impact on the validity of the transaction as a whole\&. This is the recommended way to hook start\-up of one unit to the start\-up of another unit\&.
.sp
Note that dependencies of this type may also be configured outside of the unit configuration file by adding symlinks to a
\&.wants/
directory accompanying the unit file\&. For details, see above\&.
.RE
.PP
\fIBindsTo=\fR
.RS 4
Configures requirement dependencies, very similar in style to
\fIRequires=\fR\&. However, this dependency type is stronger: in addition to the effect of
\fIRequires=\fR
it declares that if the unit bound to is stopped, this unit will be stopped too\&. This means a unit bound to another unit that suddenly enters inactive state will be stopped too\&. Units can suddenly, unexpectedly enter inactive state for different reasons: the main process of a service unit might terminate on its own choice, the backing device of a device unit might be unplugged or the mount point of a mount unit might be unmounted without involvement of the system and service manager\&.
.sp
When used in conjunction with
\fIAfter=\fR
on the same unit the behaviour of
\fIBindsTo=\fR
is even stronger\&. In this case, the unit bound to strictly has to be in active state for this unit to also be in active state\&. This not only means a unit bound to another unit that suddenly enters inactive state, but also one that is bound to another unit that gets skipped due to a failed condition check (such as
\fIConditionPathExists=\fR,
\fIConditionPathIsSymbolicLink=\fR, \&... \(em see below) will be stopped, should it be running\&. Hence, in many cases it is best to combine
\fIBindsTo=\fR
with
\fIAfter=\fR\&.
.sp
When
\fIBindsTo=b\&.service\fR
is used on
a\&.service, this dependency will show as
\fIBoundBy=a\&.service\fR
in property listing of
b\&.service\&.
\fIBoundBy=\fR
dependency cannot be specified directly\&.
.RE
.PP
\fIPartOf=\fR
.RS 4
Configures dependencies similar to
\fIRequires=\fR, but limited to stopping and restarting of units\&. When systemd stops or restarts the units listed here, the action is propagated to this unit\&. Note that this is a one\-way dependency\ \&\(em changes to this unit do not affect the listed units\&.
.sp
When
\fIPartOf=b\&.service\fR
is used on
a\&.service, this dependency will show as
\fIConsistsOf=a\&.service\fR
in property listing of
b\&.service\&.
\fIConsistsOf=\fR
dependency cannot be specified directly\&.
.RE
.PP
\fIConflicts=\fR
.RS 4
A space\-separated list of unit names\&. Configures negative requirement dependencies\&. If a unit has a
\fIConflicts=\fR
setting on another unit, starting the former will stop the latter and vice versa\&. Note that this setting is independent of and orthogonal to the
\fIAfter=\fR
and
\fIBefore=\fR
ordering dependencies\&.
.sp
If a unit A that conflicts with a unit B is scheduled to be started at the same time as B, the transaction will either fail (in case both are required parts of the transaction) or be modified to be fixed (in case one or both jobs are not a required part of the transaction)\&. In the latter case, the job that is not required will be removed, or in case both are not required, the unit that conflicts will be started and the unit that is conflicted is stopped\&.
.RE
.PP
\fIBefore=\fR, \fIAfter=\fR
.RS 4
These two settings expect a space\-separated list of unit names\&. They configure ordering dependencies between units\&. If a unit
foo\&.service
contains a setting
\fBBefore=bar\&.service\fR
and both units are being started,
bar\&.service\*(Aqs start\-up is delayed until
foo\&.service
has finished starting up\&. Note that this setting is independent of and orthogonal to the requirement dependencies as configured by
\fIRequires=\fR,
\fIWants=\fR
or
\fIBindsTo=\fR\&. It is a common pattern to include a unit name in both the
\fIAfter=\fR
and
\fIRequires=\fR
options, in which case the unit listed will be started before the unit that is configured with these options\&. This option may be specified more than once, in which case ordering dependencies for all listed names are created\&.
\fIAfter=\fR
is the inverse of
\fIBefore=\fR, i\&.e\&. while
\fIAfter=\fR
ensures that the configured unit is started after the listed unit finished starting up,
\fIBefore=\fR
ensures the opposite, that the configured unit is fully started up before the listed unit is started\&. Note that when two units with an ordering dependency between them are shut down, the inverse of the start\-up order is applied\&. i\&.e\&. if a unit is configured with
\fIAfter=\fR
on another unit, the former is stopped before the latter if both are shut down\&. Given two units with any ordering dependency between them, if one unit is shut down and the other is started up, the shutdown is ordered before the start\-up\&. It doesn\*(Aqt matter if the ordering dependency is
\fIAfter=\fR
or
\fIBefore=\fR, in this case\&. It also doesn\*(Aqt matter which of the two is shut down, as long as one is shut down and the other is started up\&. The shutdown is ordered before the start\-up in all cases\&. If two units have no ordering dependencies between them, they are shut down or started up simultaneously, and no ordering takes place\&. It depends on the unit type when precisely a unit has finished starting up\&. Most importantly, for service units start\-up is considered completed for the purpose of
\fIBefore=\fR/\fIAfter=\fR
when all its configured start\-up commands have been invoked and they either failed or reported start\-up success\&.
.RE
.PP
\fIOnFailure=\fR
.RS 4
A space\-separated list of one or more units that are activated when this unit enters the
"failed"
state\&. A service unit using
\fIRestart=\fR
enters the failed state only after the start limits are reached\&.
.RE
.PP
\fIPropagatesReloadTo=\fR, \fIReloadPropagatedFrom=\fR
.RS 4
A space\-separated list of one or more units where reload requests on this unit will be propagated to, or reload requests on the other unit will be propagated to this unit, respectively\&. Issuing a reload request on a unit will automatically also enqueue a reload request on all units that the reload request shall be propagated to via these two settings\&.
.RE
.PP
\fIJoinsNamespaceOf=\fR
.RS 4
For units that start processes (such as service units), lists one or more other units whose network and/or temporary file namespace to join\&. This only applies to unit types which support the
\fIPrivateNetwork=\fR,
\fINetworkNamespacePath=\fR
and
\fIPrivateTmp=\fR
directives (see
\fBsystemd.exec\fR(5)
for details)\&. If a unit that has this setting set is started, its processes will see the same
/tmp,
/var/tmp
and network namespace as one listed unit that is started\&. If multiple listed units are already started, it is not defined which namespace is joined\&. Note that this setting only has an effect if
\fIPrivateNetwork=\fR/\fINetworkNamespacePath=\fR
and/or
\fIPrivateTmp=\fR
is enabled for both the unit that joins the namespace and the unit whose namespace is joined\&.
.RE
.PP
\fIRequiresMountsFor=\fR
.RS 4
Takes a space\-separated list of absolute paths\&. Automatically adds dependencies of type
\fIRequires=\fR
and
\fIAfter=\fR
for all mount units required to access the specified path\&.
.sp
Mount points marked with
\fBnoauto\fR
are not mounted automatically through
local\-fs\&.target, but are still honored for the purposes of this option, i\&.e\&. they will be pulled in by this unit\&.
.RE
.PP
\fIOnFailureJobMode=\fR
.RS 4
Takes a value of
"fail",
"replace",
"replace\-irreversibly",
"isolate",
"flush",
"ignore\-dependencies"
or
"ignore\-requirements"\&. Defaults to
"replace"\&. Specifies how the units listed in
\fIOnFailure=\fR
will be enqueued\&. See
\fBsystemctl\fR(1)\*(Aqs
\fB\-\-job\-mode=\fR
option for details on the possible values\&. If this is set to
"isolate", only a single unit may be listed in
\fIOnFailure=\fR\&.\&.
.RE
.PP
\fIIgnoreOnIsolate=\fR
.RS 4
Takes a boolean argument\&. If
\fBtrue\fR, this unit will not be stopped when isolating another unit\&. Defaults to
\fBfalse\fR
for service, target, socket, busname, timer, and path units, and
\fBtrue\fR
for slice, scope, device, swap, mount, and automount units\&.
.RE
.PP
\fIStopWhenUnneeded=\fR
.RS 4
Takes a boolean argument\&. If
\fBtrue\fR, this unit will be stopped when it is no longer used\&. Note that, in order to minimize the work to be executed, systemd will not stop units by default unless they are conflicting with other units, or the user explicitly requested their shut down\&. If this option is set, a unit will be automatically cleaned up if no other active unit requires it\&. Defaults to
\fBfalse\fR\&.
.RE
.PP
\fIRefuseManualStart=\fR, \fIRefuseManualStop=\fR
.RS 4
Takes a boolean argument\&. If
\fBtrue\fR, this unit can only be activated or deactivated indirectly\&. In this case, explicit start\-up or termination requested by the user is denied, however if it is started or stopped as a dependency of another unit, start\-up or termination will succeed\&. This is mostly a safety feature to ensure that the user does not accidentally activate units that are not intended to be activated explicitly, and not accidentally deactivate units that are not intended to be deactivated\&. These options default to
\fBfalse\fR\&.
.RE
.PP
\fIAllowIsolate=\fR
.RS 4
Takes a boolean argument\&. If
\fBtrue\fR, this unit may be used with the
\fBsystemctl isolate\fR
command\&. Otherwise, this will be refused\&. It probably is a good idea to leave this disabled except for target units that shall be used similar to runlevels in SysV init systems, just as a precaution to avoid unusable system states\&. This option defaults to
\fBfalse\fR\&.
.RE
.PP
\fIDefaultDependencies=\fR
.RS 4
Takes a boolean argument\&. If
\fBtrue\fR, (the default), a few default dependencies will implicitly be created for the unit\&. The actual dependencies created depend on the unit type\&. For example, for service units, these dependencies ensure that the service is started only after basic system initialization is completed and is properly terminated on system shutdown\&. See the respective man pages for details\&. Generally, only services involved with early boot or late shutdown should set this option to
\fBfalse\fR\&. It is highly recommended to leave this option enabled for the majority of common units\&. If set to
\fBfalse\fR, this option does not disable all implicit dependencies, just non\-essential ones\&.
.RE
.PP
\fICollectMode=\fR
.RS 4
Tweaks the "garbage collection" algorithm for this unit\&. Takes one of
\fBinactive\fR
or
\fBinactive\-or\-failed\fR\&. If set to
\fBinactive\fR
the unit will be unloaded if it is in the
\fBinactive\fR
state and is not referenced by clients, jobs or other units \(em however it is not unloaded if it is in the
\fBfailed\fR
state\&. In
\fBfailed\fR
mode, failed units are not unloaded until the user invoked
\fBsystemctl reset\-failed\fR
on them to reset the
\fBfailed\fR
state, or an equivalent command\&. This behaviour is altered if this option is set to
\fBinactive\-or\-failed\fR: in this case the unit is unloaded even if the unit is in a
\fBfailed\fR
state, and thus an explicitly resetting of the
\fBfailed\fR
state is not necessary\&. Note that if this mode is used unit results (such as exit codes, exit signals, consumed resources, \&...) are flushed out immediately after the unit completed, except for what is stored in the logging subsystem\&. Defaults to
\fBinactive\fR\&.
.RE
.PP
\fIFailureAction=\fR, \fISuccessAction=\fR
.RS 4
Configure the action to take when the unit stops and enters a failed state or inactive state\&. Takes one of
\fBnone\fR,
\fBreboot\fR,
\fBreboot\-force\fR,
\fBreboot\-immediate\fR,
\fBpoweroff\fR,
\fBpoweroff\-force\fR,
\fBpoweroff\-immediate\fR,
\fBexit\fR, and
\fBexit\-force\fR\&. In system mode, all options are allowed\&. In user mode, only
\fBnone\fR,
\fBexit\fR, and
\fBexit\-force\fR
are allowed\&. Both options default to
\fBnone\fR\&.
.sp
If
\fBnone\fR
is set, no action will be triggered\&.
\fBreboot\fR
causes a reboot following the normal shutdown procedure (i\&.e\&. equivalent to
\fBsystemctl reboot\fR)\&.
\fBreboot\-force\fR
causes a forced reboot which will terminate all processes forcibly but should cause no dirty file systems on reboot (i\&.e\&. equivalent to
\fBsystemctl reboot \-f\fR) and
\fBreboot\-immediate\fR
causes immediate execution of the
\fBreboot\fR(2)
system call, which might result in data loss (i\&.e\&. equivalent to
\fBsystemctl reboot \-ff\fR)\&. Similarly,
\fBpoweroff\fR,
\fBpoweroff\-force\fR,
\fBpoweroff\-immediate\fR
have the effect of powering down the system with similar semantics\&.
\fBexit\fR
causes the manager to exit following the normal shutdown procedure, and
\fBexit\-force\fR
causes it terminate without shutting down services\&. When
\fBexit\fR
or
\fBexit\-force\fR
is used by default the exit status of the main process of the unit (if this applies) is returned from the service manager\&. However, this may be overridden with
\fIFailureActionExitStatus=\fR/\fISuccessActionExitStatus=\fR, see below\&.
.RE
.PP
\fIFailureActionExitStatus=\fR, \fISuccessActionExitStatus=\fR
.RS 4
Controls the exit status to propagate back to an invoking container manager (in case of a system service) or service manager (in case of a user manager) when the
\fIFailureAction=\fR/\fISuccessAction=\fR
are set to
\fBexit\fR
or
\fBexit\-force\fR
and the action is triggered\&. By default the exit status of the main process of the triggering unit (if this applies) is propagated\&. Takes a value in the range 0\&...255 or the empty string to request default behaviour\&.
.RE
.PP
\fIJobTimeoutSec=\fR, \fIJobRunningTimeoutSec=\fR
.RS 4
When a job for this unit is queued, a timeout
\fIJobTimeoutSec=\fR
may be configured\&. Similarly,
\fIJobRunningTimeoutSec=\fR
starts counting when the queued job is actually started\&. If either time limit is reached, the job will be cancelled, the unit however will not change state or even enter the
"failed"
mode\&. This value defaults to
"infinity"
(job timeouts disabled), except for device units (\fIJobRunningTimeoutSec=\fR
defaults to
\fIDefaultTimeoutStartSec=\fR)\&. NB: this timeout is independent from any unit\-specific timeout (for example, the timeout set with
\fITimeoutStartSec=\fR
in service units) as the job timeout has no effect on the unit itself, only on the job that might be pending for it\&. Or in other words: unit\-specific timeouts are useful to abort unit state changes, and revert them\&. The job timeout set with this option however is useful to abort only the job waiting for the unit state to change\&.
.RE
.PP
\fIJobTimeoutAction=\fR, \fIJobTimeoutRebootArgument=\fR
.RS 4
\fIJobTimeoutAction=\fR
optionally configures an additional action to take when the timeout is hit, see description of
\fIJobTimeoutSec=\fR
and
\fIJobRunningTimeoutSec=\fR
above\&. It takes the same values as
\fIStartLimitAction=\fR\&. Defaults to
\fBnone\fR\&.
\fIJobTimeoutRebootArgument=\fR
configures an optional reboot string to pass to the
\fBreboot\fR(2)
system call\&.
.RE
.PP
\fIStartLimitIntervalSec=\fR\fI\fIinterval\fR\fR, \fIStartLimitBurst=\fR\fI\fIburst\fR\fR
.RS 4
Configure unit start rate limiting\&. Units which are started more than
\fIburst\fR
times within an
\fIinterval\fR
time interval are not permitted to start any more\&. Use
\fIStartLimitIntervalSec=\fR
to configure the checking interval (defaults to
\fIDefaultStartLimitIntervalSec=\fR
in manager configuration file, set it to 0 to disable any kind of rate limiting)\&. Use
\fIStartLimitBurst=\fR
to configure how many starts per interval are allowed (defaults to
\fIDefaultStartLimitBurst=\fR
in manager configuration file)\&. These configuration options are particularly useful in conjunction with the service setting
\fIRestart=\fR
(see
\fBsystemd.service\fR(5)); however, they apply to all kinds of starts (including manual), not just those triggered by the
\fIRestart=\fR
logic\&. Note that units which are configured for
\fIRestart=\fR
and which reach the start limit are not attempted to be restarted anymore; however, they may still be restarted manually at a later point, after the
\fIinterval\fR
has passed\&. From this point on, the restart logic is activated again\&. Note that
\fBsystemctl reset\-failed\fR
will cause the restart rate counter for a service to be flushed, which is useful if the administrator wants to manually start a unit and the start limit interferes with that\&. Note that this rate\-limiting is enforced after any unit condition checks are executed, and hence unit activations with failing conditions do not count towards this rate limit\&. This setting does not apply to slice, target, device, and scope units, since they are unit types whose activation may either never fail, or may succeed only a single time\&.
.sp
When a unit is unloaded due to the garbage collection logic (see above) its rate limit counters are flushed out too\&. This means that configuring start rate limiting for a unit that is not referenced continuously has no effect\&.
.RE
.PP
\fIStartLimitAction=\fR
.RS 4
Configure an additional action to take if the rate limit configured with
\fIStartLimitIntervalSec=\fR
and
\fIStartLimitBurst=\fR
is hit\&. Takes the same values as the setting
\fIFailureAction=\fR/\fISuccessAction=\fR
settings and executes the same actions\&. If
\fBnone\fR
is set, hitting the rate limit will trigger no action besides that the start will not be permitted\&. Defaults to
\fBnone\fR\&.
.RE
.PP
\fIRebootArgument=\fR
.RS 4
Configure the optional argument for the
\fBreboot\fR(2)
system call if
\fIStartLimitAction=\fR
or
\fIFailureAction=\fR
is a reboot action\&. This works just like the optional argument to
\fBsystemctl reboot\fR
command\&.
.RE
.PP
\fIConditionArchitecture=\fR, \fIConditionVirtualization=\fR, \fIConditionHost=\fR, \fIConditionKernelCommandLine=\fR, \fIConditionKernelVersion=\fR, \fIConditionSecurity=\fR, \fIConditionCapability=\fR, \fIConditionACPower=\fR, \fIConditionNeedsUpdate=\fR, \fIConditionFirstBoot=\fR, \fIConditionPathExists=\fR, \fIConditionPathExistsGlob=\fR, \fIConditionPathIsDirectory=\fR, \fIConditionPathIsSymbolicLink=\fR, \fIConditionPathIsMountPoint=\fR, \fIConditionPathIsReadWrite=\fR, \fIConditionDirectoryNotEmpty=\fR, \fIConditionFileNotEmpty=\fR, \fIConditionFileIsExecutable=\fR, \fIConditionUser=\fR, \fIConditionGroup=\fR, \fIConditionControlGroupController=\fR, \fIConditionMemory=\fR, \fIConditionCPUs=\fR
.RS 4
Before starting a unit, verify that the specified condition is true\&. If it is not true, the starting of the unit will be (mostly silently) skipped, however all ordering dependencies of it are still respected\&. A failing condition will not result in the unit being moved into the
"failed"
state\&. The condition is checked at the time the queued start job is to be executed\&. Use condition expressions in order to silently skip units that do not apply to the local running system, for example because the kernel or runtime environment doesn\*(Aqt require their functionality\&. Use the various
\fIAssertArchitecture=\fR,
\fIAssertVirtualization=\fR, \&... options for a similar mechanism that causes the job to fail (instead of being skipped) and results in logging about the failed check (instead of being silently processed)\&. For details about assertion conditions see below\&.
.sp
\fIConditionArchitecture=\fR
may be used to check whether the system is running on a specific architecture\&. Takes one of
"x86",
"x86\-64",
"ppc",
"ppc\-le",
"ppc64",
"ppc64\-le",
"ia64",
"parisc",
"parisc64",
"s390",
"s390x",
"sparc",
"sparc64",
"mips",
"mips\-le",
"mips64",
"mips64\-le",
"alpha",
"arm",
"arm\-be",
"arm64",
"arm64\-be",
"sh",
"sh64",
"m68k",
"tilegx",
"cris",
"arc",
"arc\-be"
to test against a specific architecture\&. The architecture is determined from the information returned by
\fBuname\fR(2)
and is thus subject to
\fBpersonality\fR(2)\&. Note that a
\fIPersonality=\fR
setting in the same unit file has no effect on this condition\&. A special architecture name
"native"
is mapped to the architecture the system manager itself is compiled for\&. The test may be negated by prepending an exclamation mark\&.
.sp
\fIConditionVirtualization=\fR
may be used to check whether the system is executed in a virtualized environment and optionally test whether it is a specific implementation\&. Takes either boolean value to check if being executed in any virtualized environment, or one of
"vm"
and
"container"
to test against a generic type of virtualization solution, or one of
"qemu",
"kvm",
"zvm",
"vmware",
"microsoft",
"oracle",
"xen",
"bochs",
"uml",
"bhyve",
"qnx",
"openvz",
"lxc",
"lxc\-libvirt",
"systemd\-nspawn",
"docker",
"rkt",
"wsl",
"acrn"
to test against a specific implementation, or
"private\-users"
to check whether we are running in a user namespace\&. See
\fBsystemd-detect-virt\fR(1)
for a full list of known virtualization technologies and their identifiers\&. If multiple virtualization technologies are nested, only the innermost is considered\&. The test may be negated by prepending an exclamation mark\&.
.sp
\fIConditionHost=\fR
may be used to match against the hostname or machine ID of the host\&. This either takes a hostname string (optionally with shell style globs) which is tested against the locally set hostname as returned by
\fBgethostname\fR(2), or a machine ID formatted as string (see
\fBmachine-id\fR(5))\&. The test may be negated by prepending an exclamation mark\&.
.sp
\fIConditionKernelCommandLine=\fR
may be used to check whether a specific kernel command line option is set (or if prefixed with the exclamation mark unset)\&. The argument must either be a single word, or an assignment (i\&.e\&. two words, separated
"=")\&. In the former case the kernel command line is searched for the word appearing as is, or as left hand side of an assignment\&. In the latter case, the exact assignment is looked for with right and left hand side matching\&.
.sp
\fIConditionKernelVersion=\fR
may be used to check whether the kernel version (as reported by
\fBuname \-r\fR) matches a certain expression (or if prefixed with the exclamation mark does not match it)\&. The argument must be a single string\&. If the string starts with one of
"<",
"<=",
"=",
"!=",
">=",
">"
a relative version comparison is done, otherwise the specified string is matched with shell\-style globs\&.
.sp
Note that using the kernel version string is an unreliable way to determine which features are supported by a kernel, because of the widespread practice of backporting drivers, features, and fixes from newer upstream kernels into older versions provided by distributions\&. Hence, this check is inherently unportable and should not be used for units which may be used on different distributions\&.
.sp
\fIConditionSecurity=\fR
may be used to check whether the given security technology is enabled on the system\&. Currently, the recognized values are
"selinux",
"apparmor",
"tomoyo",
"ima",
"smack",
"audit"
and
"uefi\-secureboot"\&. The test may be negated by prepending an exclamation mark\&.
.sp
\fIConditionCapability=\fR
may be used to check whether the given capability exists in the capability bounding set of the service manager (i\&.e\&. this does not check whether capability is actually available in the permitted or effective sets, see
\fBcapabilities\fR(7)
for details)\&. Pass a capability name such as
"CAP_MKNOD", possibly prefixed with an exclamation mark to negate the check\&.
.sp
\fIConditionACPower=\fR
may be used to check whether the system has AC power, or is exclusively battery powered at the time of activation of the unit\&. This takes a boolean argument\&. If set to
"true", the condition will hold only if at least one AC connector of the system is connected to a power source, or if no AC connectors are known\&. Conversely, if set to
"false", the condition will hold only if there is at least one AC connector known and all AC connectors are disconnected from a power source\&.
.sp
\fIConditionNeedsUpdate=\fR
takes one of
/var
or
/etc
as argument, possibly prefixed with a
"!"
(for inverting the condition)\&. This condition may be used to conditionalize units on whether the specified directory requires an update because
/usr\*(Aqs modification time is newer than the stamp file
\&.updated
in the specified directory\&. This is useful to implement offline updates of the vendor operating system resources in
/usr
that require updating of
/etc
or
/var
on the next following boot\&. Units making use of this condition should order themselves before
\fBsystemd-update-done.service\fR(8), to make sure they run before the stamp file\*(Aqs modification time gets reset indicating a completed update\&.
.sp
\fIConditionFirstBoot=\fR
takes a boolean argument\&. This condition may be used to conditionalize units on whether the system is booting up with an unpopulated
/etc
directory (specifically: an
/etc
with no
/etc/machine\-id)\&. This may be used to populate
/etc
on the first boot after factory reset, or when a new system instance boots up for the first time\&.
.sp
With
\fIConditionPathExists=\fR
a file existence condition is checked before a unit is started\&. If the specified absolute path name does not exist, the condition will fail\&. If the absolute path name passed to
\fIConditionPathExists=\fR
is prefixed with an exclamation mark ("!"), the test is negated, and the unit is only started if the path does not exist\&.
.sp
\fIConditionPathExistsGlob=\fR
is similar to
\fIConditionPathExists=\fR, but checks for the existence of at least one file or directory matching the specified globbing pattern\&.
.sp
\fIConditionPathIsDirectory=\fR
is similar to
\fIConditionPathExists=\fR
but verifies whether a certain path exists and is a directory\&.
.sp
\fIConditionPathIsSymbolicLink=\fR
is similar to
\fIConditionPathExists=\fR
but verifies whether a certain path exists and is a symbolic link\&.
.sp
\fIConditionPathIsMountPoint=\fR
is similar to
\fIConditionPathExists=\fR
but verifies whether a certain path exists and is a mount point\&.
.sp
\fIConditionPathIsReadWrite=\fR
is similar to
\fIConditionPathExists=\fR
but verifies whether the underlying file system is readable and writable (i\&.e\&. not mounted read\-only)\&.
.sp
\fIConditionDirectoryNotEmpty=\fR
is similar to
\fIConditionPathExists=\fR
but verifies whether a certain path exists and is a non\-empty directory\&.
.sp
\fIConditionFileNotEmpty=\fR
is similar to
\fIConditionPathExists=\fR
but verifies whether a certain path exists and refers to a regular file with a non\-zero size\&.
.sp
\fIConditionFileIsExecutable=\fR
is similar to
\fIConditionPathExists=\fR
but verifies whether a certain path exists, is a regular file and marked executable\&.
.sp
\fIConditionUser=\fR
takes a numeric
"UID", a UNIX user name, or the special value
"@system"\&. This condition may be used to check whether the service manager is running as the given user\&. The special value
"@system"
can be used to check if the user id is within the system user range\&. This option is not useful for system services, as the system manager exclusively runs as the root user, and thus the test result is constant\&.
.sp
\fIConditionGroup=\fR
is similar to
\fIConditionUser=\fR
but verifies that the service manager\*(Aqs real or effective group, or any of its auxiliary groups match the specified group or GID\&. This setting does not have a special value
"@system"\&.
.sp
\fIConditionControlGroupController=\fR
takes a cgroup controller name (eg\&.
"cpu"), verifying that it is available for use on the system\&. For example, a particular controller may not be available if it was disabled on the kernel command line with
\fIcgroup_disable=controller\fR\&. Multiple controllers may be passed with a space separating them; in this case the condition will only pass if all listed controllers are available for use\&. Controllers unknown to systemd are ignored\&. Valid controllers are
"cpu",
"cpuacct",
"io",
"blkio",
"memory",
"devices", and
"pids"\&.
.sp
\fIConditionMemory=\fR
verifies if the specified amount of system memory is available to the current system\&. Takes a memory size in bytes as argument, optionally prefixed with a comparison operator
"<",
"<=",
"=",
"!=",
">=",
">"\&. On bare\-metal systems compares the amount of physical memory in the system with the specified size, adhering to the specified comparison operator\&. In containers compares the amount of memory assigned to the container instead\&.
.sp
\fIConditionCPUs=\fR
verifies if the specified number of CPUs is available to the current system\&. Takes a number of CPUs as argument, optionally prefixed with a comparison operator
"<",
"<=",
"=",
"!=",
">=",
">"\&. Compares the number of CPUs in the CPU affinity mask configured of the service manager itself with the specified number, adhering to the specified comparison operator\&. On physical systems the number of CPUs in the affinity mask of the service manager usually matches the number of physical CPUs, but in special and virtual environments might differ\&. In particular, in containers the affinity mask usually matches the number of CPUs assigned to the container and not the physically available ones\&.
.sp
If multiple conditions are specified, the unit will be executed if all of them apply (i\&.e\&. a logical AND is applied)\&. Condition checks can be prefixed with a pipe symbol (|) in which case a condition becomes a triggering condition\&. If at least one triggering condition is defined for a unit, then the unit will be executed if at least one of the triggering conditions apply and all of the non\-triggering conditions\&. If you prefix an argument with the pipe symbol and an exclamation mark, the pipe symbol must be passed first, the exclamation second\&. Except for
\fIConditionPathIsSymbolicLink=\fR, all path checks follow symlinks\&. If any of these options is assigned the empty string, the list of conditions is reset completely, all previous condition settings (of any kind) will have no effect\&.
.RE
.PP
\fIAssertArchitecture=\fR, \fIAssertVirtualization=\fR, \fIAssertHost=\fR, \fIAssertKernelCommandLine=\fR, \fIAssertKernelVersion=\fR, \fIAssertSecurity=\fR, \fIAssertCapability=\fR, \fIAssertACPower=\fR, \fIAssertNeedsUpdate=\fR, \fIAssertFirstBoot=\fR, \fIAssertPathExists=\fR, \fIAssertPathExistsGlob=\fR, \fIAssertPathIsDirectory=\fR, \fIAssertPathIsSymbolicLink=\fR, \fIAssertPathIsMountPoint=\fR, \fIAssertPathIsReadWrite=\fR, \fIAssertDirectoryNotEmpty=\fR, \fIAssertFileNotEmpty=\fR, \fIAssertFileIsExecutable=\fR, \fIAssertUser=\fR, \fIAssertGroup=\fR, \fIAssertControlGroupController=\fR
.RS 4
Similar to the
\fIConditionArchitecture=\fR,
\fIConditionVirtualization=\fR, \&..., condition settings described above, these settings add assertion checks to the start\-up of the unit\&. However, unlike the conditions settings, any assertion setting that is not met results in failure of the start job (which means this is logged loudly)\&. Note that hitting a configured assertion does not cause the unit to enter the
"failed"
state (or in fact result in any state change of the unit), it affects only the job queued for it\&. Use assertion expressions for units that cannot operate when specific requirements are not met, and when this is something the administrator or user should look into\&.
.sp
Note that neither assertion nor condition expressions result in unit state changes\&. Also note that both are checked at the time the job is to be executed, i\&.e\&. long after depending jobs and it itself were queued\&. Thus, neither condition nor assertion expressions are suitable for conditionalizing unit dependencies\&.
.RE
.PP
\fISourcePath=\fR
.RS 4
A path to a configuration file this unit has been generated from\&. This is primarily useful for implementation of generator tools that convert configuration from an external configuration file format into native unit files\&. This functionality should not be used in normal units\&.
.RE
.SH "MAPPING OF UNIT PROPERTIES TO THEIR INVERSES"
.PP
Unit settings that create a relationship with a second unit usually show up in properties of both units, for example in
\fBsystemctl show\fR
output\&. In some cases the name of the property is the same as the name of the configuration setting, but not always\&. This table lists the properties that are shown on two units which are connected through some dependency, and shows which property on "source" unit corresponds to which property on the "target" unit\&.
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&3.\ \& "Forward" and "reverse" unit properties
.TS
allbox tab(:);
lB lB lB.
T{
"Forward" property
T}:T{
"Reverse" property
T}:T{
Where used
T}
.T&
l l l
l l ^
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l ^
l l l.
T{
\fIBefore=\fR
T}:T{
\fIAfter=\fR
T}:T{
Both are unit file options
T}
T{
\fIAfter=\fR
T}:T{
\fIBefore=\fR
T}:
T{
\fIRequires=\fR
T}:T{
\fIRequiredBy=\fR
T}:T{
A unit file option; an option in the [Install] section
T}
T{
\fIWants=\fR
T}:T{
\fIWantedBy=\fR
T}:T{
A unit file option; an option in the [Install] section
T}
T{
\fIPartOf=\fR
T}:T{
\fIConsistsOf=\fR
T}:T{
A unit file option; an automatic property
T}
T{
\fIBindsTo=\fR
T}:T{
\fIBoundBy=\fR
T}:T{
A unit file option; an automatic property
T}
T{
\fIRequisite=\fR
T}:T{
\fIRequisiteOf=\fR
T}:T{
A unit file option; an automatic property
T}
T{
\fITriggers=\fR
T}:T{
\fITriggeredBy=\fR
T}:T{
Automatic properties, see notes below
T}
T{
\fIConflicts=\fR
T}:T{
\fIConflictedBy=\fR
T}:T{
A unit file option; an automatic property
T}
T{
\fIPropagatesReloadTo=\fR
T}:T{
\fIReloadPropagatedFrom=\fR
T}:T{
Both are unit file options
T}
T{
\fIReloadPropagatedFrom=\fR
T}:T{
\fIPropagatesReloadTo=\fR
T}:
T{
\fIFollowing=\fR
T}:T{
n/a
T}:T{
An automatic property
T}
.TE
.sp 1
.PP
Note:
\fIWantedBy=\fR
and
\fIRequiredBy=\fR
are used in the [Install] section to create symlinks in
\&.wants/
and
\&.requires/
directories\&. They cannot be used directly as a unit configuration setting\&.
.PP
Note:
\fIConsistsOf=\fR,
\fIBoundBy=\fR,
\fIRequisiteOf=\fR,
\fIConflictedBy=\fR
are created implicitly along with their reverse and cannot be specified directly\&.
.PP
Note:
\fITriggers=\fR
is created implicitly between a socket, path unit, or an automount unit, and the unit they activate\&. By default a unit with the same name is triggered, but this can be overridden using
\fISockets=\fR,
\fIService=\fR, and
\fIUnit=\fR
settings\&. See
\fBsystemd.service\fR(5),
\fBsystemd.socket\fR(5),
\fBsystemd.path\fR(5), and
\fBsystemd.automount\fR(5)
for details\&.
\fITriggersBy=\fR
is created implicitly on the triggered unit\&.
.PP
Note:
\fIFollowing=\fR
is used to group device aliases and points to the "primary" device unit that systemd is using to track device state, usually corresponding to a sysfs path\&. It does not show up in the "target" unit\&.
.SH "[INSTALL] SECTION OPTIONS"
.PP
Unit files may include an
"[Install]"
section, which carries installation information for the unit\&. This section is not interpreted by
\fBsystemd\fR(1)
during runtime; it is used by the
\fBenable\fR
and
\fBdisable\fR
commands of the
\fBsystemctl\fR(1)
tool during installation of a unit\&.
.PP
\fIAlias=\fR
.RS 4
A space\-separated list of additional names this unit shall be installed under\&. The names listed here must have the same suffix (i\&.e\&. type) as the unit filename\&. This option may be specified more than once, in which case all listed names are used\&. At installation time,
\fBsystemctl enable\fR
will create symlinks from these names to the unit filename\&. Note that not all unit types support such alias names, and this setting is not supported for them\&. Specifically, mount, slice, swap, and automount units do not support aliasing\&.
.RE
.PP
\fIWantedBy=\fR, \fIRequiredBy=\fR
.RS 4
This option may be used more than once, or a space\-separated list of unit names may be given\&. A symbolic link is created in the
\&.wants/
or
\&.requires/
directory of each of the listed units when this unit is installed by
\fBsystemctl enable\fR\&. This has the effect that a dependency of type
\fIWants=\fR
or
\fIRequires=\fR
is added from the listed unit to the current unit\&. The primary result is that the current unit will be started when the listed unit is started\&. See the description of
\fIWants=\fR
and
\fIRequires=\fR
in the [Unit] section for details\&.
.sp
\fBWantedBy=foo\&.service\fR
in a service
bar\&.service
is mostly equivalent to
\fBAlias=foo\&.service\&.wants/bar\&.service\fR
in the same file\&. In case of template units,
\fBsystemctl enable\fR
must be called with an instance name, and this instance will be added to the
\&.wants/
or
\&.requires/
list of the listed unit\&. E\&.g\&.
\fBWantedBy=getty\&.target\fR
in a service
getty@\&.service
will result in
\fBsystemctl enable getty@tty2\&.service\fR
creating a
getty\&.target\&.wants/getty@tty2\&.service
link to
getty@\&.service\&.
.RE
.PP
\fIAlso=\fR
.RS 4
Additional units to install/deinstall when this unit is installed/deinstalled\&. If the user requests installation/deinstallation of a unit with this option configured,
\fBsystemctl enable\fR
and
\fBsystemctl disable\fR
will automatically install/uninstall units listed in this option as well\&.
.sp
This option may be used more than once, or a space\-separated list of unit names may be given\&.
.RE
.PP
\fIDefaultInstance=\fR
.RS 4
In template unit files, this specifies for which instance the unit shall be enabled if the template is enabled without any explicitly set instance\&. This option has no effect in non\-template unit files\&. The specified string must be usable as instance identifier\&.
.RE
.PP
The following specifiers are interpreted in the Install section: %n, %N, %p, %i, %j, %g, %G, %U, %u, %m, %H, %b, %v\&. For their meaning see the next section\&.
.SH "SPECIFIERS"
.PP
Many settings resolve specifiers which may be used to write generic unit files referring to runtime or unit parameters that are replaced when the unit files are loaded\&. Specifiers must be known and resolvable for the setting to be valid\&. The following specifiers are understood:
.sp
.it 1 an-trap
.nr an-no-space-flag 1
.nr an-break-flag 1
.br
.B Table\ \&4.\ \&Specifiers available in unit files
.TS
allbox tab(:);
lB lB lB.
T{
Specifier
T}:T{
Meaning
T}:T{
Details
T}
.T&
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l
l l l.
T{
"%b"
T}:T{
Boot ID
T}:T{
The boot ID of the running system, formatted as string\&. See \fBrandom\fR(4) for more information\&.
T}
T{
"%C"
T}:T{
Cache directory root
T}:T{
This is either /var/cache (for the system manager) or the path "$XDG_CACHE_HOME" resolves to (for user managers)\&.
T}
T{
"%E"
T}:T{
Configuration directory root
T}:T{
This is either /etc (for the system manager) or the path "$XDG_CONFIG_HOME" resolves to (for user managers)\&.
T}
T{
"%f"
T}:T{
Unescaped filename
T}:T{
This is either the unescaped instance name (if applicable) with / prepended (if applicable), or the unescaped prefix name prepended with /\&. This implements unescaping according to the rules for escaping absolute file system paths discussed above\&.
T}
T{
"%h"
T}:T{
User home directory
T}:T{
This is the home directory of the user running the service manager instance\&. In case of the system manager this resolves to "/root"\&.
T}
T{
"%H"
T}:T{
Host name
T}:T{
The hostname of the running system at the point in time the unit configuration is loaded\&.
T}
T{
"%i"
T}:T{
Instance name
T}:T{
For instantiated units this is the string between the first "@" character and the type suffix\&. Empty for non\-instantiated units\&.
T}
T{
"%I"
T}:T{
Unescaped instance name
T}:T{
Same as "%i", but with escaping undone\&.
T}
T{
"%j"
T}:T{
Final component of the prefix
T}:T{
This is the string between the last "\-" and the end of the prefix name\&. If there is no "\-", this is the same as "%p"\&.
T}
T{
"%J"
T}:T{
Unescaped final component of the prefix
T}:T{
Same as "%j", but with escaping undone\&.
T}
T{
"%L"
T}:T{
Log directory root
T}:T{
This is either /var/log (for the system manager) or the path "$XDG_CONFIG_HOME" resolves to with /log appended (for user managers)\&.
T}
T{
"%m"
T}:T{
Machine ID
T}:T{
The machine ID of the running system, formatted as string\&. See \fBmachine-id\fR(5) for more information\&.
T}
T{
"%n"
T}:T{
Full unit name
T}:T{
\ \&
T}
T{
"%N"
T}:T{
Full unit name
T}:T{
Same as "%n", but with the type suffix removed\&.
T}
T{
"%p"
T}:T{
Prefix name
T}:T{
For instantiated units, this refers to the string before the first "@" character of the unit name\&. For non\-instantiated units, same as "%N"\&.
T}
T{
"%P"
T}:T{
Unescaped prefix name
T}:T{
Same as "%p", but with escaping undone\&.
T}
T{
"%s"
T}:T{
User shell
T}:T{
This is the shell of the user running the service manager instance\&. In case of the system manager this resolves to "/bin/sh"\&.
T}
T{
"%S"
T}:T{
State directory root
T}:T{
This is either /var/lib (for the system manager) or the path "$XDG_CONFIG_HOME" resolves to (for user managers)\&.
T}
T{
"%t"
T}:T{
Runtime directory root
T}:T{
This is either /run (for the system manager) or the path "$XDG_RUNTIME_DIR" resolves to (for user managers)\&.
T}
T{
"%T"
T}:T{
Directory for temporary files
T}:T{
This is either /tmp or the path "$TMPDIR", "$TEMP" or "$TMP" are set to\&.
T}
T{
"%g"
T}:T{
User group
T}:T{
This is the name of the group running the service manager instance\&. In case of the system manager this resolves to "root"\&.
T}
T{
"%G"
T}:T{
User GID
T}:T{
This is the numeric GID of the user running the service manager instance\&. In case of the system manager this resolves to "0"\&.
T}
T{
"%u"
T}:T{
User name
T}:T{
This is the name of the user running the service manager instance\&. In case of the system manager this resolves to "root"\&.
T}
T{
"%U"
T}:T{
User UID
T}:T{
This is the numeric UID of the user running the service manager instance\&. In case of the system manager this resolves to "0"\&.
T}
T{
"%v"
T}:T{
Kernel release
T}:T{
Identical to \fBuname \-r\fR output
T}
T{
"%V"
T}:T{
Directory for larger and persistent temporary files
T}:T{
This is either /var/tmp or the path "$TMPDIR", "$TEMP" or "$TMP" are set to\&.
T}
T{
"%%"
T}:T{
Single percent sign
T}:T{
Use "%%" in place of "%" to specify a single percent sign\&.
T}
.TE
.sp 1
.SH "EXAMPLES"
.PP
\fBExample\ \&1.\ \&Allowing units to be enabled\fR
.PP
The following snippet (highlighted) allows a unit (e\&.g\&.
foo\&.service) to be enabled via
\fBsystemctl enable\fR:
.sp
.if n \{\
.RS 4
.\}
.nf
[Unit]
Description=Foo

[Service]
ExecStart=/usr/sbin/foo\-daemon

\fI[Install]\fR
\fIWantedBy=multi\-user\&.target\fR
.fi
.if n \{\
.RE
.\}
.PP
After running
\fBsystemctl enable\fR, a symlink
/etc/systemd/system/multi\-user\&.target\&.wants/foo\&.service
linking to the actual unit will be created\&. It tells systemd to pull in the unit when starting
multi\-user\&.target\&. The inverse
\fBsystemctl disable\fR
will remove that symlink again\&.
.PP
\fBExample\ \&2.\ \&Overriding vendor settings\fR
.PP
There are two methods of overriding vendor settings in unit files: copying the unit file from
/usr/lib/systemd/system
to
/etc/systemd/system
and modifying the chosen settings\&. Alternatively, one can create a directory named
\fIunit\fR\&.d/
within
/etc/systemd/system
and place a drop\-in file
\fIname\fR\&.conf
there that only changes the specific settings one is interested in\&. Note that multiple such drop\-in files are read if present, processed in lexicographic order of their filename\&.
.PP
The advantage of the first method is that one easily overrides the complete unit, the vendor unit is not parsed at all anymore\&. It has the disadvantage that improvements to the unit file by the vendor are not automatically incorporated on updates\&.
.PP
The advantage of the second method is that one only overrides the settings one specifically wants, where updates to the unit by the vendor automatically apply\&. This has the disadvantage that some future updates by the vendor might be incompatible with the local changes\&.
.PP
This also applies for user instances of systemd, but with different locations for the unit files\&. See the section on unit load paths for further details\&.
.PP
Suppose there is a vendor\-supplied unit
/usr/lib/systemd/system/httpd\&.service
with the following contents:
.sp
.if n \{\
.RS 4
.\}
.nf
[Unit]
Description=Some HTTP server
After=remote\-fs\&.target sqldb\&.service
Requires=sqldb\&.service
AssertPathExists=/srv/webserver

[Service]
Type=notify
ExecStart=/usr/sbin/some\-fancy\-httpd\-server
Nice=5

[Install]
WantedBy=multi\-user\&.target
.fi
.if n \{\
.RE
.\}
.PP
Now one wants to change some settings as an administrator: firstly, in the local setup,
/srv/webserver
might not exist, because the HTTP server is configured to use
/srv/www
instead\&. Secondly, the local configuration makes the HTTP server also depend on a memory cache service,
memcached\&.service, that should be pulled in (\fIRequires=\fR) and also be ordered appropriately (\fIAfter=\fR)\&. Thirdly, in order to harden the service a bit more, the administrator would like to set the
\fIPrivateTmp=\fR
setting (see
\fBsystemd.exec\fR(5)
for details)\&. And lastly, the administrator would like to reset the niceness of the service to its default value of 0\&.
.PP
The first possibility is to copy the unit file to
/etc/systemd/system/httpd\&.service
and change the chosen settings:
.sp
.if n \{\
.RS 4
.\}
.nf
[Unit]
Description=Some HTTP server
After=remote\-fs\&.target sqldb\&.service \fImemcached\&.service\fR
Requires=sqldb\&.service \fImemcached\&.service\fR
AssertPathExists=\fI/srv/www\fR

[Service]
Type=notify
ExecStart=/usr/sbin/some\-fancy\-httpd\-server
\fINice=0\fR
\fIPrivateTmp=yes\fR

[Install]
WantedBy=multi\-user\&.target
.fi
.if n \{\
.RE
.\}
.PP
Alternatively, the administrator could create a drop\-in file
/etc/systemd/system/httpd\&.service\&.d/local\&.conf
with the following contents:
.sp
.if n \{\
.RS 4
.\}
.nf
[Unit]
After=memcached\&.service
Requires=memcached\&.service
# Reset all assertions and then re\-add the condition we want
AssertPathExists=
AssertPathExists=/srv/www

[Service]
Nice=0
PrivateTmp=yes
.fi
.if n \{\
.RE
.\}
.PP
Note that for drop\-in files, if one wants to remove entries from a setting that is parsed as a list (and is not a dependency), such as
\fIAssertPathExists=\fR
(or e\&.g\&.
\fIExecStart=\fR
in service units), one needs to first clear the list before re\-adding all entries except the one that is to be removed\&. Dependencies (\fIAfter=\fR, etc\&.) cannot be reset to an empty list, so dependencies can only be added in drop\-ins\&. If you want to remove dependencies, you have to override the entire unit\&.
.SH "SEE ALSO"
.PP
\fBsystemd\fR(1),
\fBsystemctl\fR(1),
\fBsystemd-system.conf\fR(5),
\fBsystemd.special\fR(7),
\fBsystemd.service\fR(5),
\fBsystemd.socket\fR(5),
\fBsystemd.device\fR(5),
\fBsystemd.mount\fR(5),
\fBsystemd.automount\fR(5),
\fBsystemd.swap\fR(5),
\fBsystemd.target\fR(5),
\fBsystemd.path\fR(5),
\fBsystemd.timer\fR(5),
\fBsystemd.scope\fR(5),
\fBsystemd.slice\fR(5),
\fBsystemd.time\fR(7),
\fBsystemd-analyze\fR(1),
\fBcapabilities\fR(7),
\fBsystemd.directives\fR(7),
\fBuname\fR(1)
.SH "NOTES"
.IP " 1." 4
Interface Stability Promise
.RS 4
\%https://www.freedesktop.org/wiki/Software/systemd/InterfaceStabilityPromise
.RE
